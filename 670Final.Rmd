---
title: "670 Final Project Black Litterman"
author: "Chuan Bai, Zhongshi Qiu, Pu Shi, Ning Zhao"
date: "December 11, 2016"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

#1.Download Data and Get Returns
```{r warning=FALSE, message=FALSE}
setwd("C:/Users/ZhaoN/Desktop/670/")
extract <- function(args){
  stocks <- t(read.table(args[1],sep=",")[1,])
  J <- length(stocks)
  #dir.create("data", showWarnings = FALSE)
  path <- "http://ichart.finance.yahoo.com/table.csv?s="
  for(j in 1:J){
    dat <- read.csv(paste(path,stocks[j],sep=""))
    write.csv(dat, file=paste("C:/Users/ZhaoN/Desktop/670/",
                        stocks[j],sep=""),row.names=FALSE, quote=FALSE)
  }
}
extract("stocks.txt")
extract_price <- function(args){
  stocks <- t(read.table(args[1], sep=",")[1,])
  J <- length(stocks)
  N <- as.integer(250)
  dat <- read.csv(paste("C:/Users/ZhaoN/Desktop/670/", stocks[1], sep=""))
  price <- dat[1:N,5]
  if(J > 1){
    for(j in 2:J){
      dat <- read.csv(paste("C:/Users/ZhaoN/Desktop/670/",
                            stocks[j], sep=""))
      price <- cbind(price, dat[1:N,5])
    }
  }
  write.table(price, file=paste("C:/Users/ZhaoN/Desktop/670/", 
                                file="portfolio.txt", sep=""),row.names=FALSE, 
              col.names=stocks,quote=FALSE, sep=",")
  return(price)
}
price <- extract_price("stocks.txt")
read_data <- function(args){
  data <- read.table(paste("C:/Users/ZhaoN/Desktop/670/", file="portfolio.txt", sep=""),
                     header=TRUE, sep=",");
  return(list(data, as.integer(100),
              as.double(0.01)));
}
returns <- function(data){
  dat <- data[[1]]; N <- nrow(dat) - 1; J <- ncol(dat);
  ret <- (dat[1:N,1] - dat[2:(N+1),1])/dat[2:(N+1),1];
  if(J > 1){
    for(j in 2:J){
      ret <- cbind(ret, (dat[1:N,j] - dat[2:(N+1),j])/
                     dat[2:(N+1),j])
    }
  }
  return(list(ret, names(data[[1]]), data[[2]], data[[3]]));
}
data <- read_data(args)
retu <- returns(data)
# Stock daily return
stockreturns <- returns(data)[[1]]
```

#2.Calculate Parameters
```{r warning=FALSE, message=FALSE}
library(quantmod)
Syms <- c('MMM', 'AYI', 'AES', 'LNT', 'ALLE', 'AEE', 'AEP', 'AWK', 'AME', 'APH', 'BLL', 
          'BBY', 'CNP', 'CF', 'CMS', 'ED', 'GLW', 'DE', 'D', 'DUK', 'ETN', 'EIX', 'ETR', 
          'MLM', 'XYL', 'XEL', 'WEC', 'VMC', 'UTX')
whatMatrix <- yahooQF(c('Market Capitalization',"P/E Ratio", 
                        "Price/EPS Estimate Next Year", "PEG Ratio", "Dividend Yield"))
market.cap <- getQuote(paste(Syms, sep="", collapse=";"), what=whatMatrix)
market.cap[26,2]<-c("18.08B")
s<-strsplit(market.cap[,2], 'B')
marcap<-as.numeric(s)
capwei<-rep(0,29)
for(i in 1:length(marcap)){
  capwei[i]<-(marcap[i]/sum(marcap))
}
#-----------------------------------
colnames(stockreturns)<-c('MMM', 'AYI', 'AES', 'LNT', 'ALLE', 'AEE', 'AEP', 'AWK', 
                          'AME', 'APH', 'BLL', 'BBY', 'CNP', 'CF', 'CMS', 'ED', 
                          'GLW', 'DE', 'D', 'DUK', 'ETN', 'EIX', 'ETR', 'FTV', 'XYL', 
                          'XEL', 'WEC', 'VMC', 'UTX')
sigma <- apply(stockreturns,2,sd)*sqrt(252) #Get Standard deviation of sectors
rho <- cor(stockreturns) # Get Correlation matrix
cc <- mean(upper.tri(rho, diag=FALSE)) # Get Average pairwise correlation
rho[rho != 1] <- cc
cov.mat <- rho * (sigma %*% t(sigma))
# Get Annual Expected Return
ret.total <- stockreturns%*%capwei
er <- mean(ret.total)*252
rf <- 0.02 # 10 Y Annual US Yield are about 2%
votr <- var(ret.total)*252 # Variance of the total return
lambda <- (er-rf)/votr
pi <- c(lambda)*(cov.mat%*%capwei)
```

#3.Optimal Portfolio  
```{r warning=FALSE, message=FALSE}
optimization <- function(returns){
  p <- colMeans(returns[[1]]); names(p) <- returns[[2]];
  J <- ncol(returns[[1]]); M <- returns[[3]];
  Rmax <- returns[[4]];
  S <- cov(returns[[1]]); Q <- solve(S); u <- rep(1,J);
  a <- matrix(rep(0,4),nrow=2);
  a[1,1] <- u%*%Q%*%u;
  a[1,2] <- a[2,1] <- u%*%Q%*%p;
  a[2,2] <- p%*%Q%*%p;
  d <- a[1,1]*a[2,2] - a[1,2]*a[1,2];
  f <- (Q%*%( a[2,2]*u - a[1,2]*p))/d;
  g <- (Q%*%(-a[1,2]*u + a[1,1]*p))/d;
  r <- seq(0, Rmax, length=M);
  w <- matrix(rep(0,J*M), nrow=J);
  for(m in 1:M) w[,m] <- f + r[m]*g;
  s <- sqrt( a[1,1]*((r - a[1,2]/a[1,1])^2)/d + 1/a[1,1]);
  ss <- sqrt(diag(S));
  minp <- c(sqrt(1/a[1,1]), a[1,2]/a[1,1]);
  wminp <- f + (a[1,2]/a[1,1])*g;
  tanp <- c(sqrt(a[2,2])/a[1,2], a[2,2]/a[1,2]);
  wtanp <- f + (a[2,2]/a[1,2])*g;
  Q <- sqrt(diag(1.0/ss));
  x <- eigen(Q%*%S%*%Q);
  v <- Q%*%x$vec;
  for(j in 1:J) v[,j] <- v[,j]/(u%*%v[,j]);
  sv <- rv <- rep(0, J);
  for(j in 1:J){
    rv[j] <- t(v[,j])%*%p;
    if(rv[j] < 0){
      rv[j] <- -rv[j];
      v[,j] <- -v[,j];
    }
    sv[j] <- sqrt(t(v[,j])%*%S%*%v[,j]);
  }
  return(list(s, r, ss, p, minp, tanp, wminp, wtanp,
              w, v, sv, rv));
}
plot_results<- function(data, returns, results){
  dat <- log(data[[1]]); M <- nrow(dat); J <- ncol(dat);
  ymax = max(dat); ymin = min(dat)
  mycolors <- rainbow(J+1);
  s <- results[[1]]; r <- results[[2]];
  ss <- results[[3]]; p <- results[[4]];
  minp <- results[[5]]; tanp <- results[[6]];
  wminp <- results[[7]]; wtanp <- results[[8]];
  f <- t(results[[9]]); v <- results[[10]];
  sv <- results[[11]]; rv <- results[[12]];
  #postscript(file="./results1/fig1.eps", onefile=FALSE,
  #           horizontal=FALSE, height=10, width=5);

  id <- c(1:nrow(dat));
  plot(id, rev(dat[,1]), ylim=c(ymin, ymax), type="l",
       col=mycolors[1], xlab="day", ylab="log(price)",
       main = "Asset Prices");
  if(J > 1){
    for(j in 2:J){
      lines(id, rev(dat[,j]), type="l",
            col=mycolors[j]);
    }
  }
  legend("topleft", names(dat), cex=0.435, pch=rep(15, J),
         col=mycolors);
  ret <- returns[[1]];
  ymax = max(ret); ymin = min(ret);
  id <- c(1:nrow(ret));
  plot(id, rev(ret[,1]), ylim=c(ymin, ymax), type="l",
       col=mycolors[1], xlab="day", ylab="returns",
       main = "Asset Returns");
  if(J > 1){
    for(j in 2:J){
      lines(id, rev(ret[,j]),type="l",col=mycolors[j]);
    }
  }
  legend("topleft", returns[[2]], cex=0.435, pch=rep(15, J),
         col=mycolors);
  #postscript(file="./results1/fig2.eps", onefile=FALSE,
  #           horizontal=FALSE, height=10, width=5);

  plot(s, r, xlim=c(0,max(s)), ylim=c(min(r,p), max(r,p)),
       type="l", col="blue", xlab="risk", ylab="return",
       main = "Efficient Frontier, MVP1, TGP");
  points(ss, p, pch=19, col=mycolors);
  text(ss, p, pos=4, cex=0.5, names(p));
  points(sv[1], rv[1], pch=15, col="black");
  text(sv[1], rv[1], pos=4, cex=0.5, "DEP");
  points(minp[1], minp[2], pch=19, col="black");
  text(minp[1], minp[2], pos=2, cex=0.5, "MVP1");
  points(tanp[1], tanp[2], pch=19, col="black");
  text(tanp[1], tanp[2], pos=2, cex=0.5, "TGP");
  lines(c(0,max(s)), c(0,max(s)*tanp[2]/tanp[1]), lty=3);
  abline(h=0, lty=2); abline(v=0, lty=2);
  plot(s, f[,1], xlim=c(0,max(s)), ylim=c(min(f),max(f)),
       col=mycolors[1], type="l",
       xlab="risk", ylab="portfolio weights",
       main = "Efficient Portfolio Weights");
  if(J > 1){
    for(j in 2:J){
      lines(s, f[,j], type="l", col=mycolors[j]);
    }
  }
  abline(h=0, lty=2); abline(v=minp[1], lty=3);
  abline(v=tanp[1], lty=3);
  text(minp[1], min(f), pos=4, cex=0.5, "MVP1");
  text(tanp[1], min(f), pos=4, cex=0.5, "TGP");
  legend("topleft", names(p), cex=0.435, pch=rep(15, J),
         col=mycolors);
  #postscript(file="./results1/fig3.eps", onefile=FALSE,
  #           horizontal=FALSE, height=10, width=5);
  
  barplot(wminp, main="Minimum Variance Portfolio 1 (MVP1)",
          xlab="Assets", ylab="Weights",
          col=mycolors, beside=TRUE);
  abline(h=0, lty=1);
  legend("topleft", names(p), cex=0.435, pch=rep(15, J),
         col=mycolors);
  barplot(wtanp, main="Tangency Portfolio (TGP)",
          xlab="Assets", ylab="Weights", col=mycolors,
          beside=TRUE);
  abline(h=0, lty=1);
  legend("topleft", names(p), cex=0.435, pch=rep(15, J),
         col=mycolors);
  barplot(v[,1], main="Dominant Eigen-Portfolio (DEP)",
          xlab="Assets", ylab="Weights", col=mycolors,
          beside=TRUE);
  abline(h=0, lty=1);
  legend("topleft", names(p), cex=0.435, pch=rep(15, J), col=
           mycolors);
}
results <- optimization(retu)
wminp<-results[[7]]
```

#4.Black Litterman Model
```{r warning=FALSE, message=FALSE}
library(quadprog)
library(MASS)
library(BLCOP)
# Download P/E ratio and PEG ratio
earn <- cbind(as.numeric(market.cap$`P/E Ratio`),as.numeric(market.cap$`PEG Ratio`))
rownames(earn) <- Syms
colnames(earn) <- c('P/E','PEG')
earn <- na.omit(earn)
gross <- data.frame("Gross Rate"=earn[,1]/earn[,2])

# Pick up matrix
pick <- matrix(0, ncol = length(capwei), nrow = 11, 
               dimnames = list(NULL,letters[1:length(capwei)])) 
#view1: MMM will outperform AEE
pick[1,1] <- 1
pick[1,6] <- -1
q1 <- (gross["MMM",]-gross["AEE",])*0.01
#view2: AYI will outperform LNT
pick[2,2] <- 1
pick[2,4] <- -1
q2 <- (gross["AYI",]-gross["LNT",])*0.01
#view3: AME will outperform AEP
pick[3,9] <- 1
pick[3,7] <- -1
q3 <- (gross["AME",]-gross["AEP",])*0.01
#view4: ALLE will outperform AWK
pick[4,5] <- 1
pick[4,8] <- -1
q4 <- (gross["ALLE",]-gross["AWK",])*0.01
#view5: BLL will outperform CF
pick[5,11] <- 1
pick[5,14] <- -1
q5 <- (gross["BLL",]-gross["CF",])*0.01
#view6: BBY will outperform ED
pick[6,12] <- 1
pick[6,16] <- -1
q6 <- (gross["BBY",]-gross["ED",])*0.01
#view7: DE will outperform CMS
pick[7,18] <- 1
pick[7,15] <- -1
q7 <- (gross["DE",]-gross["CMS",])*0.01
#view8: GLW will outperform D
pick[8,17] <- 1
pick[8,19] <- -1
q8 <- (gross["GLW",]-gross["D",])*0.01
#view9: ETN will outperform ETR
pick[9,21] <- 1
pick[9,23] <- -1
q9 <- (gross["ETN",]-gross["ETR",])*0.01
#view10: VMC will outperform UTX
pick[10,28] <- 1
pick[10,29] <- -1
q10 <- (gross["VMC",]-gross["UTX",])*0.01
#view11: XYL will outperform DUK
pick[11,25] <- 1
pick[11,20] <- -1
q11 <- (gross["XYL",]-gross["DUK",])*0.01

# Confidence level
confidences <- c(0.0709, 0.00141, 0.00866,0.0136,0.004557,
                 0.0632,0.02411,0.00873,0.00732,0.123,0.579) 
views <- BLViews(pick, c(q1,q2,q3,q4,q5,q6,q7,q8,q9,q10,q11), 
                 confidences, letters[1:length(capwei)]) 
# New expected return and new covariance matrix
posterior <- posteriorEst(views, tau = 0.025, as.numeric(pi), cov.mat)
library(tseries)
# Get the weights based on BL, no short
blw <- portfolio.optim(matrix(posterior@posteriorMean,nrow=1),
                       covmat=posterior@posteriorCovar,shorts=F,riskless=F,
                       reslow=rep(0,length(capwei)))
blw <- blw$pw
# Get the weights based on MVP, no short
blw.long <- portfolio.optim(matrix(colMeans(252*stockreturns),nrow=1),covmat=
                              cov.mat,shorts=F,riskless=F,reslow=rep(0,length(capwei)))
w.long<-blw.long$pw

# plot asset price, asset return, efficient frointer, MVP,TGP
plot_results(data, retu, results)
# BL weights
barplot(blw,col=rainbow(29),ylab="Weights",main="Black Litterman Weights")
legend("bottom",inset=c(0,-0.3),legend=Syms,fill=rainbow(29),cex=0.72,ncol=8,xpd=TRUE)
# MVP weights, allow short
barplot(wminp[,1],col=rainbow(29),ylab="Weights",main="MVP Weights")
legend("bottom",inset=c(0,-0.3),legend=Syms,fill=rainbow(29),cex=0.72,ncol=8,xpd=TRUE)
# MVP weights, no short
barplot(w.long,col=rainbow(29),ylab="Weights",main="MVP-Long Weights")
legend("bottom",inset=c(0,-0.3),legend=Syms,fill=rainbow(29),cex=0.72,ncol=8,xpd=TRUE)
```

#5.Performance and Back Test
```{r warning=FALSE, message=FALSE}
# Benchmark
SPX <- read.csv(file='http://ichart.finance.yahoo.com/table.csv?s=^GSPC')
SPX <- SPX$Adj.Close[1:250]
SPX.r <- Delt(rev(SPX))[-1,]*100

# Portfolio Performance
Capital <- 1000000
N <- nrow(price)
w <- floor(Capital * wminp / price[N,] /100) *100 * price[N,] / Capital
DailyRtnPort <- rev(stockreturns %*% w *100)
PortIndex <- rev(price %*% w)

w.long <- floor(Capital * w.long / price[N,] /100) *100 * price[N,] / Capital
DailyRtnPort.long <- rev(stockreturns %*% w.long *100)
PortIndex.long <- rev(price %*% w.long)

blww <- floor(Capital * blw / price[N,] /100) *100 * price[N,] / Capital
bl.DailyRtnPort <- rev(stockreturns %*% blww *100)
bl.PortIndex <- rev(price %*% blww)

D <- length(PortIndex)
DrawDown <-c()
DrawDown.long <- c()
bl.DrawDown<-c()
Spx.DrawDown <- c()
for (i in 1:D)
{
  DrawDown[i] <- max(0,max(PortIndex[1:i])-PortIndex[i])/max(PortIndex[1:i])
  DrawDown.long[i] <- max(0,max(PortIndex.long[1:i])-PortIndex.long[i])/
    max(PortIndex.long[1:i])
  bl.DrawDown[i] <- max(0,max(bl.PortIndex[1:i])-bl.PortIndex[i])/max(bl.PortIndex[1:i])
  Spx.DrawDown[i] <- max(0,max(rev(SPX)[1:i])- rev(SPX)[i])/max(rev(SPX)[1:i])
}
MaxDrawDown <- max(DrawDown)
MaxDrawDown.long <- max(DrawDown.long)
bl.MaxDrawDown <- max(bl.DrawDown)
SPX.MaxDrawDown <- max(Spx.DrawDown)

# Daily return
plot(rep(1:(D-1)),DailyRtnPort,type="l",col="red",main="Daily Return",xlab="Time",
     ylab="Return(%)",ylim=c(-3.5,3.5))
lines(rep(1:(D-1)),DailyRtnPort.long,col="yellow")
lines(rep(1:(D-1)),bl.DailyRtnPort,col="blue")
lines(rep(1:(D-1)),SPX.r,col="green")
legend("topright",legend=c('BL','MVP','MVP-Long','SPX'),
       fill=c('blue','red','yellow','green'),cex=0.7)
# MDD
MaxY <- max(MaxDrawDown,MaxDrawDown.long,bl.MaxDrawDown,SPX.MaxDrawDown)
plot(rep(1:D),DrawDown,type="l",col="red",main="DrawDown",xlab="Time",ylab="Percentage",
     ylim=c(0,MaxY))
lines(rep(1:D),DrawDown.long,type="l",col="yellow")
lines(rep(1:D),bl.DrawDown,type="l",col="blue")
lines(rep(1:D),Spx.DrawDown,type="l",col="green")
legend("topright",legend=c('BL','MVP','MVP-Long','SPX'),
       fill=c('blue','red','yellow','green'),cex=0.8)
# Holding period return
HPR <- (price[1,] %*% w)/(price[N,] %*% w)-1
HPR.long <- (price[1,] %*% w.long)/(price[N,] %*% w.long)-1
bl.HPR <- (price[1,] %*% blww)/(price[N,] %*% blww)-1
SPX.HPR <- SPX[1]/SPX[N]-1
barplot(100*c(HPR,HPR.long,bl.HPR,SPX.HPR),col=c("red","yellow","blue","green"),
        names.arg=c("MVP","MVP-Long","BL","Benchmark"),ylab="Return(%)",
        main="Holding Period Return")


#---------- Back-testing ----------
D <- N/2
BT.w <- floor(Capital * wminp / price[D,] /100) *100 * price[D,] / Capital
BT.w.long <- floor(Capital * w.long / price[D,] /100) *100 * price[D,] / Capital
BT.blw <- floor(Capital * blw / price[D,] /100) *100 * price[D,] / Capital

BT.HPR <- (price[1,] %*% BT.w)/(price[D,] %*% BT.w)-1
BT.HPR.long <- (price[1,] %*% BT.w.long)/(price[D,] %*% BT.w.long)-1
BT.bl.HPR <- (price[1,] %*% BT.blw)/(price[D,] %*% BT.blw)-1
BT.SPX.HPR <- SPX[1]/SPX[D]-1
barplot(100*c(BT.HPR,BT.HPR.long,BT.bl.HPR,BT.SPX.HPR),col=c("red","yellow","blue","green"),
        names.arg=c("MVP","MVP-Long","BL","Benchmark"),ylab="Return(%)"
        ,main = "Holding Period Return for Back-Testing")
```

#6. Risk Management
```{r warning=FALSE, message=FALSE}
# ============ Mean-Variance Portfolio Risk Management ==========
# consider 99% confidence level
alpha <- 1.96
initial.value <- 1000000
port.Return <- mean(stockreturns%*%wminp)
port.sigma <- sqrt(t(wminp)%*%cov.mat%*%wminp)
port.VaR <- initial.value*alpha*port.sigma
# individual VaR
individual.Var <- c()
for(i in 1:length(wminp))
{
  variance <- sd(stockreturns[,i])
  individual.Var[i] <- initial.value*alpha*variance*abs(wminp[i])
}
# to answer the question as "which position should I alter to modify my VaR most effectively"
# margin VaR
mar.VaR <- c()
beta.port <- c()
for(i in 1:length(wminp))
{
  port.re <- stockreturns[,-i]%*%wminp[-i]
  port.sig <- sqrt(t(wminp[-i])%*%cov.mat[-i,-i]%*%wminp[-i])
  mar.VaR[i] <- (alpha*cov(stockreturns[,i],port.re))/port.sig
  beta.port[i] <- (cov(stockreturns[,i],port.re))/port.sig^2
}
# best hedge ratio
best.hedge <- c()
mar.VaR
for (i in 1: length(wminp))
{
  variance <- var(stockreturns[,i]) 
  best.hedge[i] <- -beta.port[i]*port.sigma^2/variance
}
# risk decomposition of VaR
cVaR_Per <- wminp*beta.port
cVaR <- port.VaR*beta.port*wminp
# ============ Black-litterman Portfolio Risk Management ==========
port.Return.bl <- mean(stockreturns%*%blw)
port.sigma.bl <- sqrt(t(blw)%*%cov.mat%*%blw)
port.VaR.bl <- initial.value*alpha*port.sigma.bl
port.VaR.bl
# individual VaR
individual.Var.bl <- c()
for(i in 1:length(blw))
{
  variance <- sd(stockreturns[,i])
  individual.Var.bl[i] <- initial.value*alpha*variance*blw[i]
}
individual.Var.bl
sum(individual.Var.bl)
# to answer the question as "which position should I alter to modify my VaR most effectively"
# margin VaR
mar.VaR.bl <- c()
beta.port.bl <- c()
for(i in 1:length(blw))
{
  port.re <- stockreturns[,-i]%*%blw[-i]
  port.sig.bl <- sqrt(t(blw[-i])%*%cov.mat[-i,-i]%*%blw[-i])
  mar.VaR.bl[i] <- alpha*cov(stockreturns[,i],port.re)/port.sig.bl
  beta.port.bl[i] <- cov(stockreturns[,i],port.re)/port.sig.bl^2
}
as.data.frame(mar.VaR.bl)
names(mar.VaR.bl) <- c('MMM', 'AYI','AES', 'LNT', 'ALLE','AEE','AEP','AWK', 'AME', 'APH', 
                       'BLL','BBY', 'CNP','CF','CMS', 'ED','GLW', 'DE', 'D', 'DUK','ETN',
                       'EIX','ETR','FTV','XYL','XEL','WEC','VMC','UTX')
# best hedge ratio
best.hedge.bl <- c()
for (i in 1: length(blw))
{
  variance <- var(stockreturns[,i]) 
  best.hedge.bl[i] <- -beta.port.bl[i]*port.sigma.bl^2/variance
}
best.hedge.bl
# risk decomposition of VaR
cVaR_Per.bl <- blw*beta.port.bl
as.data.frame(cVaR_Per.bl)
cVaR.bl <- port.VaR.bl*beta.port.bl*blw
```